# 디플로이먼트(Deployment) 으로 MySQL 만들기

<br />
<br />

* DB를 만들려면 고려해야 하는 점

---

```
디비 이미지를 컨테이너 만들고 파드로 관리할 때 가장 중요한 점은
영속성을 가져야 한다는 것이다.

디비를 만들 때,
볼륨을 연결하지 않고, 볼륨을 연결했을 때와 안 했을 때의 장단점을 알아보자.
```

<br />
<br />
<br />
<br />

1. 매니페스트 파일 생성하기

<br />

`mysql-deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment

# Deployment 기본 정보
metadata:
  name: mysql-deployment # Deployment 이름

# Deployment 세부 정보
spec:
  replicas: 1 # 생성할 파드의 복제본 개수
  selector:
    matchLabels:
      app: mysql-db # 아래에서 정의한 Pod 중 'app: mysql-db'이라는 값을 가진 파드를 선택
  # 배포할 Pod 정의
  template:
    metadata:
      labels: # 레이블 (= 카테고리)
        app: mysql-db
    spec:
      containers:
        - name: mysql-container # 컨테이너 이름
        image: mysql # 컨테이너를 생성할 때 사용할 이미지
        ports:
        - containerPort: 3306 # 컨테이너에서 사용하는 포트를 명시적으로 표현
        env:
          - name: MYSQL_ROOT_PASSWORD
            value: password123
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: mysql-root-password
          - name: MYSQL_DATABASE
            value: kub-practice
            valueFrom:
              configMapKeyRef:
                name: mysql-config
                key: mysql-database
```

<br />

`mysql-secret.yaml`

```yaml
apiVersion: v1
kind: Secret

# Secret 기본 정보
metadata:
  name: mysql-secret # Secret 이름

# Key, Value 형식으로 값 저장
stringData:
  mysql-root-password: password123
```

<br />

`mysql-config.yaml`

```yaml
apiVersion: v1
kind: ConfigMap

# ConfigMap 기본 정보
metadata:
  name: mysql-config # ConfigMap 이름

# Key, Value 형식으로 설정값 저장
data:
  mysql-database: kub-practice
```

<br />

`mysql-service.yaml`

```yaml
apiVersion: v1
kind: Service

# Service 기본 정보
metadata:
  name: mysql-service # Service 이름

# Service 세부 정보
spec:
  type: NodePort # Service의 종류
  selector:
    app: mysql-db # 실행되고 있는 파드 중 'app: mysql-db'이라는 값을 가진 파드와 서비스를 연결
  ports:
    - protocol: TCP # 서비스에 접속하기 위한 프로토콜
      port: 3306 # 쿠버네티스 내부에서 Service에 접속하기 위한 포트 번호
      targetPort: 3306 # 매핑하기 위한 파드의 포트 번호
      nodePort: 30002 # 외부에서 사용자들이 접근하 될 포트 번호
```

<br />
<br />
<br />

2. 매니페스트 기반으로 오브젝트 생성하기

```
$ kubectl apply -f mysql-secret.yaml
$ kubectl apply -f mysql-config.yaml
$ kubectl apply -f mysql-deployment.yaml
$ kubectl apply -f mysql-service.yaml
```

<br />
<br />
<br />

3. DB 접속해보기

| 속성    | 값           |
|--------|-------------|
| 호스트   | localhost   |
| 포트    | 30002       |
| 유저    | root        |
| 패스워드 | password123 |

<br />
<br />
<br />

4. 데이터베이스 확인

```
"kub-practice" 라는 데이터베이스가 생성되었는지 확인한다.

그리고 "test" 라는 데이터베이스를 생성해보자.
```

<br />
<br />
<br />

5. MySQL 재시작시키기

```
여기서 MySQL가 이유 모를 장애로 서비스가 중단됐다고 가정하자.

그래서 디플로이먼트를 다시 시작해야 하는 상황이라고 해보자.
```

```
# 디플로이먼트 재시작
$ kubectl rollout restart deployment mysql-deployment
```

```
이제 데이터베이스를 다시 확인해 보면,
"test" 데이터베이스는 사라졌을 것이다.

쿠버네티스는 재시작 시 통째로 파드를 바꿔버리기 때문이다.

그렇기 때문에 데이터베이스 같은 경우 반드시 볼륨을 연결해 사용해야 한다.
```

<br />
<br />
<br />

6. 영속성 볼륨을 연결해보자.

```
실제 데이터베이스에서는 데이터가 없어져서는 안 된다.

데이터가 보존되도록 볼륨(Volume)을 설정해보자.
```

<br />

`mysql-pv.yaml`

```yaml
apiVersion: v1
kind: PersistentVolume

# PersistentVolume 기본 정보
metadata:
  name: mysql-pv # PersistentVolume 이름

# PersistentVolume 세부 정보
spec:
  storageClassName: mysql-storage # PV와 PVC의 storageClassName이 같다면 볼륨이 연결된다.
  capacity:
    storage: 10Gi # 볼륨이 사용할 용량을 설정
  accessModes:
    - ReadWriteOnce # 아래 hostPath 타입 활용 시 이 옵션만 사용 가능
  hostPath: # hostPath 타입을 활용 (hostPath : 쿠버네티스 내부 공간을 활용)
    path: "/mnt/data" # 쿠버네티스 내부의 공간에서 /mnt/data의 경로를 볼륨으로 사용
```

<br />

`mysql-pvc.yaml`

```yaml
apiVersion: v1
kind: PersistentVolumeClaim

# PersistentVolumeClaim 기본 정보
metadata:
  name: mysql-pvc # PersistentVolumeClaim 이름

# PersistentVolumeClaim 세부 정보
spec:
  storageClassName: mysql-storage # PV와 PVC의 storageClassName이 같다면 볼륨이 연결
  accessModes:
    - ReadWriteOnce # 볼륨에 접근할 때의 권한
  resources: # PVC가 PV에 요청하는 리소스의 양을 정의
    requests: # 필요한 최소 리소스
      storage: 10Gi # PVC가 PV에 요청하는 스토리지 양 (PV가 최소 1Gi 이상은 되어야 한다.)
```

<br />

`기존 mysql-deployment.yaml 수정`

```yaml

...

  template:
    metadata:
      labels: # 레이블 (= 카테고리)
        app: mysql-db
    spec:
      containers:
        - name: mysql-container # 컨테이너 이름
        image: mysql # 컨테이너를 생성할 때 사용할 이미지
        ports:
        - containerPort: 3306 # 컨테이너에서 사용하는 포트를 명시적으로 표현
        env:
          - name: MYSQL_ROOT_PASSWORD
            value: password123
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: mysql-root-password
          - name: MYSQL_DATABASE
            value: kub-practice
            valueFrom:
              configMapKeyRef:
                name: mysql-config
                key: mysql-database
        # 컨테이너 내에서 어떤 경로를 볼륨으로 사용할 지 지정
        volumeMounts:
          - name: mysql-persistent-storage # 밑에서 설정할 volumes.name과 값이 같아야 함
            mountPath: /var/lib/mysql # mysql 컨테이너 내부에 있는 경로
      volumes:
        - name: mysql-persistent-storage # 위에서 설정할 volumeMounts.name과 일치해야 함
          persistentVolumeClaim:
            claimName: mysql-pvc # 연결시킬 PVC의 name과 동일해야 함
```

<br />
<br />
<br />

7. 매니페스트 파일 반영하기

```
$ kubectl apply -f mysql-pv.yaml
$ kubectl apply -f mysql-pvc.yaml
$ kubectl apply -f mysql-deployment.yaml
```

<br />
<br />
<br />

8. 새로운 데이터베이스 생성하기

```
새로운 데이터 베이스를 생성한다.

이름은 test으로 한다.
```

<br />
<br />
<br />

9. 디플로이먼트 재시작하기

```
# deployment 재시작
$ kubectl rollout restart deployment mysql-deployment
```

```
디플로이먼트를 재시작하기 전에 생성했던 데이터베이스가 삭제되지 않고,
그대로 잘 남아있는 걸 확인할 수 있다.
```
