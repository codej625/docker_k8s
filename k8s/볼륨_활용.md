# 백엔드(Spring Boot) 서버와 MySQL 연동하기

<br />
<br />

* 볼륨을 사용해 디비에 영속성을 주고 백엔드 서버와 연결해 보자.

---

```
일반적으로 앱 서버와 연동하는 디비는 영속을 갖고 있다.

여기서는 디비에 볼륨을 사용하고 앱 서버와 연결하는 작업을 해보자.
```

<br />
<br />
<br />
<br />

1. start.spring.io 접속하기

```
start.spring.io 사이트에 접속해서
Spring Boot 프로젝트를 셋팅한다.

* 반드시 사용하려는 디비에 맞게 의존성(드라이버)을 선택해야 한다.
```

<br />
<br />
<br />

2. 간단한 코드 작성

<br />

`TestController.java`

```java
package com.health.healthapp;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    
    @GetMapping("/test")
    public String test() {
        return "Spring Boot Application is running";
    }
}

```

<br />
<br />
<br />

3. application.properties에 DB 연결을 위한 정보 작성하기

<br />

`application.properties`

```properties
# APPLICATION
## 애플리케이션 이름
spring.application.name=healthapp

# SERVER
## 포트 번호
server.port=8080

# DB
## Hibernate가 해당 데이터베이스(PostgreSQL)에 최적화된 SQL을 생성
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
## 데이터베이스 연결 정보
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:30000}/${DB_NAME:healthapp}
## 데이터베이스 사용자 이름
spring.datasource.username=${DB_USERNAME:healthapp}
## 데이터베이스 사용자 비밀번호
spring.datasource.password=${DB_PASSWORD:#1234}
## 데이터베이스 스키마를 자동으로 업데이트 (default -> update)
spring.jpa.hibernate.ddl-auto=${JPA_DDL_AUTO:update}
## SQL 쿼리를 출력 (default -> true)
spring.jpa.show-sql=${JPA_SHOW_SQL:true}
## SQL 쿼리를 보기 좋게 포맷팅해서 출력 (default -> true)
spring.jpa.properties.hibernate.format_sql=${JPA_FORMAT_SQL:true} 
## 데이터베이스 드라이버 클래스 이름
spring.datasource.driver-class-name=org.postgresql.Driver

# SPRING SECURITY
## 스프링 시큐리티 사용자 이름
spring.security.user.name=admin
## 스프링 시큐리티 사용자 비밀번호
spring.security.user.password=#1234
## 스프링 시큐리티 사용자 역할
spring.security.user.roles=ADMIN
## 스프링 시큐리티 활성화 여부
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
```

<br />

`application-dev.properties`

```properties
# SERVER
## 포트 번호
server.port=8081

# DB
## 데이터베이스 연결 정보
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:30000}/${DB_NAME:healthapp}
## 데이터베이스 사용자 이름
spring.datasource.username=${DB_USERNAME:healthapp}
## 데이터베이스 사용자 비밀번호
spring.datasource.password=${DB_PASSWORD:#1234}
## 데이터베이스 스키마를 자동으로 업데이트 (default -> update)
spring.jpa.hibernate.ddl-auto=${JPA_DDL_AUTO:update}
## SQL 쿼리를 출력 (default -> true)
spring.jpa.show-sql=${JPA_SHOW_SQL:true}
## SQL 쿼리를 보기 좋게 포맷팅해서 출력 (default -> true)
spring.jpa.properties.hibernate.format_sql=${JPA_FORMAT_SQL:true} 
## 데이터베이스 드라이버 클래스 이름
spring.datasource.driver-class-name=org.postgresql.Driver

# DEVELOPMENT SETTINGS
## 개발 환경에서 자동 재시작 기능 활성화
spring.devtools.restart.enabled=true
## 개발 환경에서 LiveReload 기능 활성화 (프론트엔드 자동 새로고침 기능)
spring.devtools.livereload.enabled=true

# ... 로깅등 여러가지 옵션 추가 필요 업데이트 중
```

<br />

`application-dev.properties`

```properties
# SERVER
## 포트 번호
server.port=8082

# ... 업데이트 중
```

<br />
<br />
<br />

4. build.gradle 파일 업데이트

<br />

`build.gradle`

```gradle

...

// 빌드 시 기본 profile을 사용하면 디비정보가 없어 에러가 난다.
tasks.named('test') {
	useJUnitPlatform()
	// 빌드 테스트에 dev profile 사용
	systemProperty 'spring.profiles.active', 'dev'
}
```

<br />
<br />
<br />

5. Dockerfile 작성하기

<br />

`Dockerfile`

```dockerfile
FROM openjdk:17-jdk

COPY build/libs/*.jar app.jar

# 환경변수로 dev profile 설정
ENV SPRING_PROFILES_ACTIVE=dev

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

<br />
<br />
<br />

6. Spring Boot 프로젝트 빌드하기

```
# 클린 빌드를 한다
$ ./gradlew clean build
```

<br />
<br />
<br />

7. 도커 이미지 빌드하기

```
# 위에서 만든 jar 파일을 사용해 도커 이미지를 빌드한다.
$ docker build -t spring-server .
```

<br />
<br />
<br />

8. 매니페스트 파일 작성하기

<br />

`spring-config.yaml`

```yaml
apiVersion: v1
kind: ConfigMap

metadata:
  name: spring-config

data:
  # 데이터베이스 설정
  ## 데이터베이스 호스트
  # db-host: localhost
  ## 데이터베이스 포트
  db-port: "5432"
  ## 데이터베이스 이름
  db-name: healthapp
  ## 데이터베이스 업데이트 옵션
  jpa-ddl-auto: update
  ## SQL 쿼리를 출력
  jpa-show-sql: "true"
  ## SQL 쿼리를 보기 좋게 포맷팅해서 출력
  jpa-format-sql: "true"
```

<br />

`spring-secret.yaml`

```yaml
apiVersion: v1
kind: Secret

metadata:
  name: spring-secret

stringData:
  # 데이터베이스 설정
  ## 데이터베이스 사용자 이름
  db-username: "healthapp"
  ## 데이터베이스 사용자 비밀번호
  db-password: "#1234"
```

<br />

`spring-deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: spring-deployment

spec:
  replicas: 1 # 생성할 파드의 복제본 개수
  selector:
    matchLabels:
      app: backend-app # 아래에서 정의한 Pod 중 'app: backend-app'이라는 값을 가진 파드를 선택

  template:
    metadata:
      labels: # 레이블 (= 카테고리)
        app: backend-app 
    spec:
      containers:
        - name: spring-container # 컨테이너 이름
          image: spring-server # 이미지 이름
          imagePullPolicy: IfNotPresent # 이미지 풀 정책
          ports:
            - containerPort: 8081 # 컨테이너 포트 번호
          resources:
            requests:
              memory: "256Mi"
              cpu: "50m"
            limits:
              memory: "512Mi"
              cpu: "100m"
          env:
            # 데이터베이스 호스트
            - name: DB_HOST
              value: postgres-service # Service의 name만 입력하면 다른 서비스와 통신할 수 있다.
            # 데이터베이스 포트
            - name: DB_PORT
              valueFrom:
                configMapKeyRef:
                  name: spring-config
                  key: db-port
            # 데이터베이스 이름
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: spring-config
                  key: db-name
            # 데이터베이스 사용자 이름
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: spring-secret
                  key: db-username
            # 데이터베이스 사용자 비밀번호
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: spring-secret
                  key: db-password
            # 데이터베이스 업데이트 옵션
            - name: JPA_DDL_AUTO
              valueFrom:
                configMapKeyRef:
                  name: spring-config
                  key: jpa-ddl-auto
            # SQL 쿼리를 출력하는 옵션
            - name: JPA_SHOW_SQL
              valueFrom:
                configMapKeyRef:
                  name: spring-config
                  key: jpa-show-sql
            # SQL 쿼리를 보기 좋게 포맷팅해서 출력하는 옵션
            - name: JPA_FORMAT_SQL
              valueFrom:
                configMapKeyRef:
                  name: spring-config
                  key: jpa-format-sql
```

<br />

`spring-service.yaml`

```yaml
apiVersion: v1
kind: Service

metadata:
  name: spring-service

spec:
  type: NodePort
  selector:
    app: backend-app
  ports:
    - protocol: TCP
      targetPort: 8081
      port: 8081
      nodePort: 30001
```

<br />

`postgres-config.yaml`

```yaml
apiVersion: v1
kind: ConfigMap

metadata:
  name: postgres-config

data:
  # 데이터베이스 이름
  postgres-database: healthapp
```

<br />

`postgres-secret.yaml`

```yaml
apiVersion: v1
kind: Secret

metadata:
  name: postgres-secret

stringData:
  # 데이터베이스 사용자 이름
  postgres-user: "healthapp"
  # 데이터베이스 사용자 비밀번호
  postgres-password: "#1234"
```

<br />

`postgres-pv.yaml`

```yaml
apiVersion: v1
kind: PersistentVolume

metadata:
  name: postgres-pv

spec:
  storageClassName: postgres-storage
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

<br />

`postgres-pvc.yaml`

```yaml
apiVersion: v1
kind: PersistentVolumeClaim

metadata:
  name: postgres-pvc

spec:
  storageClassName: postgres-storage
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

<br />

`postgres-deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: postgres-deployment

spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres-db
  
  template:
    metadata:
      labels:
        app: postgres-db
    spec:
      containers:
        - name: postgres-container
          image: postgres:15
          ports:
            - containerPort: 5432
          resources:
            requests:
              memory: "256Mi"
              cpu: "50m"
            limits:
              memory: "512Mi"
              cpu: "100m"
          env:
            # 데이터베이스 이름
            - name: POSTGRES_DATABASE
              valueFrom:
                configMapKeyRef:
                  name: postgres-config
                  key: postgres-database
            # 데이터베이스 사용자 이름
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: postgres-user
            # 데이터베이스 사용자 비밀번호
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: postgres-password
          volumeMounts:
            - name: postgres-persistent-storage
              mountPath: /var/lib/postgresql
      volumes:
        - name: postgres-persistent-storage
          persistentVolumeClaim:
            claimName: postgres-pvc

```

<br />

`postgres-service.yaml`

```yaml
apiVersion: v1
kind: Service

metadata:
  name: postgres-service

spec:
  type: ClusterIP
  selector:
    app: postgres-db
  ports:
    - protocol: TCP
      targetPort: 5432
      port: 5432
      # nodePort: 30000 # NodePort 타입으로 설정 시, 사용 가능
      # 외부 접속 필요 시, kubectl port-forward pod/[pod-name] [local-port]:[container-port] 명령어 사용
```

<br />
<br />
<br />

9. 매니페스트 파일 실행하기

```
$ kubectl apply -f spring-config.yaml
$ kubectl apply -f spring-secret.yaml
$ kubectl apply -f spring-deployment.yaml
$ kubectl apply -f spring-service.yaml
```

```
$ kubectl apply -f postgres-config.yaml
$ kubectl apply -f postgres-secret.yaml
$ kubectl apply -f postgres-pv.yaml
$ kubectl apply -f postgres-pvc.yaml
$ kubectl apply -f postgres-deployment.yaml
$ kubectl apply -f postgres-service.yaml
```

<br />
<br />
<br />

10. DB를 관리하기 위해 접속해야 할 때는?

```
# 쿠버네티스의 포트 포워딩을 활용해서 접속하면 된다.
$ kubectl port-forward pod/[PostgreSQL 파드명] 5432:5432
```
