# 인그레스 컨트롤러 활용하기

<br />
<br />

* 쿠버네티스 환경에서 Ingress Controller를 사용한 외부 트래픽 처리

---

```
Ingress 리소스의 주된 목적은 Ingress Controller를 통해, 
외부 트래픽을 클러스터 내부의 특정 Service 리소스와 연결하는 것이다.

VM을 사용해서 K3s 클러스터 구조를 만들고 MetalLB, ServiceLB 를 사용하지 않는 버전 예시이다.
(kube-vip + Traefik 사용, 하나의 클러스터에 여러 개의 인스턴스 사용)
```

<br />
<br />
<br />
<br />

1. 생성할 VM 사양 (예시)

| VM  | 역할      | CPU    | RAM | DISK  | VM IP 예시       |
|:---:|----------|--------|-----|-------|-----------------|
| VM1 | Master 1 | 2 Core | 2GB | 20GB  | 192.168.0.101   |
| VM2 | Worker 1 | 2 Core | 4GB | 50GB+ | 192.168.0.102   |
| VM3 | Worker 2 | 2 Core | 4GB | 50GB+ | 192.168.0.103   |

<br />

`* VIP IP "192.168.0.240" 이라고 가정.`

<br />
<br />
<br />

2. 각 VM 사전 설정

`1) 호스트명 설정 (각 VM에서)`

```zsh
# VM1 에서 실행
sudo hostnamectl set-hostname master-1

# VM2 에서 실행
sudo hostnamectl set-hostname worker-1

# VM3 에서 실행
sudo hostnamectl set-hostname worker-2
```

<br />

`2) /etc/hosts에 등록 (각 VM에서, IP는 예시이다.)`

```zsh
sudo tee -a /etc/hosts << EOF
192.168.0.101 master-1
192.168.0.102 worker-1
192.168.0.103 worker-2
EOF
```

<br />

`3) 방화벽 (테스트 시 포트만 오픈)`

```zsh
# Master 노드 (VM1)
sudo ufw allow 6443/tcp
sudo ufw allow 10250/tcp
sudo ufw allow 2379:2380/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
```

```zsh
# Worker 노드 (VM2, VM3)
sudo ufw allow 10250/tcp
sudo ufw allow 30000:32767/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
```

<br />
<br />
<br />

3. VM1에서 Master 1 설치

```zsh
# ServiceLB 비활성화 (kube-vip 사용), Traefik 유지, TLS SAN 추가 (IP는 VM IP에 맞게 변경 필요)
curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="--disable=servicelb --tls-san=192.168.0.101" sh -

sudo systemctl status k3s
kubectl get nodes

# 워커 조인용 토큰 확인
sudo cat /var/lib/rancher/k3s/server/node-token
```

```zsh
# SAN 이란?
SAN = Subject Alternative Name

TLS 인증서에 이 인증서로 접속해도 되는 주소 목록이 들어 있음.

그 목록에 IP나 도메인을 넣어 두어야, 
그 주소로 접속했을 때 브라우저/클라이언트가 인증서를 유효하다 인정함.
```

<br />

```zsh
mkdir -p ~/.kube
sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
sudo chown $(id -u):$(id -g) ~/.kube/config
```

```zsh
# taint 설정 (toleration이 없는 Pod(대부분의 앱) 는 마스터에 안 올라가고 워커에만 올라감)
kubectl taint nodes master-1 node-role.kubernetes.io/control-plane:NoSchedule --overwrite
```

<br />
<br />
<br />

4. VM2, VM3에서 K3s Worker 조인

`VM2, VM3에서 실행`

```zsh
export K3S_URL="https://192.168.0.101:6443"
export K3S_TOKEN="<토큰값>"
curl -sfL https://get.k3s.io | sh -
sudo systemctl status k3s-agent
```

<br />

`VM1에서 조인 확인`

```zsh
# 노드 확인
kubectl get nodes
```

| NAME     | STATUS | ROLES                | AGE | VERSION  |
|----------|--------|----------------------|-----|----------|
| master-1 | Ready  | control-plane,master | 5m  | v1.30.x  |
| worker-1 | Ready  | <none>               | 2m  | v1.30.x  |
| worker-2 | Ready  | <none>               | 1m  | v1.30.x  |

<br />
<br />
<br />

5. kube-vip 설치 (LoadBalancer용 가상 IP)

`kube-vip.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kubevip
  namespace: kube-system
data:
  config: |
    # kube-vip가 쓸 VIP. 사용 중이 아닌 IP여야 함
    address: 192.168.0.240
    # 서버에서 ip a 또는 ip link 로 확인. eth0이 아니면 ens18, enp0s3 등 실제 이름
    vip_interface: eth0
    enableServices: true
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-vip
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: kube-vip
  template:
    metadata:
      labels:
        app: kube-vip
    spec:
      containers:
      - name: kube-vip
        image: ghcr.io/kube-vip/kube-vip:latest
        securityContext:
          capabilities:
            add: ["NET_ADMIN", "SYS_TIME"]
        args:
        - start
        - -c
        - /config/config
        volumeMounts:
        - name: config
          mountPath: /config
      volumes:
      - name: config
        configMap:
          name: kubevip
      hostNetwork: true
      tolerations:
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
```

<br />

```zsh
kubectl apply -f kube-vip.yaml
kubectl wait --namespace kube-system --for=condition=ready pod --selector=app=kube-vip --timeout=90s
```

<br />

```zsh
# kube-vip Pod가 잘 떠 있는지 확인
kubectl get pods -n kube-system -l app=kube-vip
```

<br />
<br />
<br />

6. Ingress Controller 설정 (K3s 기본 Traefik)

```zsh
# VM1 에서 실행 (kube-vip address와 Traefik에 넣는 kube-vip.io/requestedIP 값을 동일하게 맞춰야 함)
kubectl patch svc traefik -n kube-system -p '{"spec": {"type": "LoadBalancer"}, "metadata": {"annotations": {"kube-vip.io/requestedIP": "192.168.0.240"}}}'
kubectl annotate svc traefik -n kube-system kube-vip.io/requestedIP=192.168.0.240 --overwrite
```

```zsh
# traefik가 잘 떠 있는지 확인
kubectl get svc -n kube-system traefik
```

<br />
<br />
<br />

7. cert-manager 설치

```zsh
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.2/cert-manager.yaml
kubectl wait --namespace cert-manager --for=condition=ready pod --selector=app.kubernetes.io/instance=cert-manager --timeout=90s
```

<br />

`letsencrypt-issuer.yaml`

```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    # 본인 이메일로 반드시 수정. Let's Encrypt가 인증서 만료·계정 관련 연락에 사용
    email: your-email@example.com
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: traefik
```

```zsh
kubectl apply -f letsencrypt-issuer.yaml
kubectl get clusterissuer
```

<br />
<br />
<br />

8. App Service 설정

`spring-svc.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: spring-svc # 사용하는 스택에 맞게 변경
  namespace: default
spec:
  type: ClusterIP
  selector:
    app: spring
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    protocol: TCP
```

<br />


`next-svc.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: next-svc # 사용하는 스택에 맞게 변경
  namespace: default
spec:
  type: ClusterIP
  selector:
    app: next
  ports:
  - name: http
    port: 3000
    targetPort: 3000
    protocol: TCP
```

```zsh
kubectl apply -f spring-svc.yaml
kubectl get svc spring-svc

kubectl apply -f next-svc.yaml
kubectl get svc next-svc
```

<br />
<br />
<br />

9. IngressClass (Traefik, 필요 시)

`ingressclass-traefik.yaml`

```yaml
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: traefik
spec:
  controller: traefik.io/ingress-controller
```

<br />

```zsh
# kubectl get ingressclass 로 traefik 있는지 보고, 없을 때만 ingressclass-traefik.yaml 적용
kubectl apply -f ingressclass-traefik.yaml
```

<br />
<br />
<br />

10. Ingress 라우팅 설정

`ingress.yaml`

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: main-ingress
  namespace: default
  annotations:
    traefik.ingress.kubernetes.io/router.tls: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  ingressClassName: traefik
  tls:
  - hosts:
    # A 레코드를 두 개 (또는 서브도메인 두 개)
    - app.example.com
    - api.example.com
    secretName: example-tls # 원하는 이름으로 (같은 도메인들이면 하나로 통일 가능)
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: next-svc
            port:
              number: 3000
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: spring-svc
            port:
              number: 8080
```

<br />

`Ingress – 경로로 나누기 (같은 도메인)`

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: main-ingress
  namespace: default
  annotations:
    traefik.ingress.kubernetes.io/router.tls: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  ingressClassName: traefik
  tls:
  - hosts:
    - example.com
    secretName: example-tls # 원하는 이름으로 (같은 도메인들이면 하나로 통일 가능)
  rules:
  - host: example.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: spring-svc
            port:
              number: 8080
      - path: /
        pathType: Prefix
        backend:
          service:
            name: next-svc
            port:
              number: 3000

# /api 가 먼저 오고 / 가 나중에 와야, /api 가 백엔드로만 가고 나머지는 Next로 감
```

```zsh
kubectl apply -f ingress.yaml
kubectl get ingress
kubectl get svc
```

---

11. 도메인 DNS 설정

```
도메인 구입처 DNS에서 A 레코드 추가. 
전파는 수분~최대 24시간 소요될 수 있음.
```

| 구분       | 설명           |
|-----------|---------------|
| 도메인     | healthapp.shop |
| 레코드     | A              |
| 호스트     | @              |
| 값(IP주소) | 공인IP          |
| TTL      | 3600 (1시간)    |

```zsh
nslookup healthapp.shop
dig healthapp.shop
```

---

12. 공유기 포트포워딩 설정

| 외부 포트    | 내부 IP        | 내부 포트   | 프로토콜   | 설명   |
|-----------|---------------|-----------|----------|-------|
| 80        | 192.168.0.240 | 80        | TCP      | HTTP  |
| 443       | 192.168.0.240 | 443       | TCP      | HTTPS |

<br />
<br />
<br />

13. 전체 시스템 확인

```zsh
kubectl get all -A
kubectl get ingress -A
kubectl get svc -n kube-system traefik
kubectl get certificate -A
kubectl logs -n kube-system -l app.kubernetes.io/name=traefik --tail=100
kubectl logs -n kube-system -l app=kube-vip --tail=50
```
